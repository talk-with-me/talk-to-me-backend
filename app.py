from flask import Flask, render_template, jsonify, request
from flask_pymongo import PyMongo
<<<<<<< Updated upstream
import db
import datetime
from flask_socketio import SocketIO, send
import time
=======
import db, json, datetime, random, uuid
from bson import json_util, ObjectId
from lib import errors
>>>>>>> Stashed changes

from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.interval import IntervalTrigger
import atexit
<<<<<<< Updated upstream
=======

# Configure app
from lib.utils import error, expect_json, success
>>>>>>> Stashed changes

app = Flask(__name__)
app.config['SECRET_KEY'] = 'ttm'
mdb = PyMongo(app, db.MONGO_URL).db 

socketio = SocketIO(app, cors_allowed_origins='*')

<<<<<<< Updated upstream
@app.route('/')
def landingPage():
    return 'Welcome to Talk to Me'

# Preferably there will be a separate app route for the landing page, and then a button the redirects to this app route
@app.route('/room/RANDOM')
def connectToRoom():    
    return render_template('index.html')

@socketio.on('message')
def handleMessage(m):
    print('Message: ' + m)
    # broadcast is set to true so that it's sent to all clients including yourself (so I can see it and the other person can see it)
    send(m, broadcast=True)

# input user data the moment they join into the website
@app.route('/inputData')
def inputData():
    mdb.userDetails.insert_one({"ip": request.remote_addr, "clientID": "some clientID", "secret": 123,  
                                "queryType": 0, "time": datetime.datetime.utcnow()})
    return "Inserted into user collection!"

# displays the collection inside the database, so query the db for its values
@app.route('/findAll', methods=['GET'])
def findAll():
    query = mdb.userDetails.find() # 'collection' is the name of the collection in this db
    output = {}
    i = 0
    for x in query:
        output[i] = x
        output[i].pop('_id')
        i += 1

    print(output)
    return output

# finds a specfic row using their secret
# find_one() - if query matches, first document is returned, otherwise null.
# find() - nomatter number of documents matched, a cursor is returned, never null.
# FYI: there is also a find_one_and_update function if needed.
@app.route('/find/<int:secret>', methods=['GET'])
def find(secret):
    query = mdb.userDetails.find_one({"secret": secret}, {"_id": 0}) # ignore _id since its ObjectID, won't display otherwise
    return query

=======
# ===== REST =====
# assign users a generated userID and secret. Stores user in db then redirects to queue selection
@app.route('/auth', methods = ['GET'])
def userAuth():
    userID = str(uuid.uuid4())
    userSecret = str(uuid.uuid4())
    userObj = {"ip": request.remote_addr, "userID": userID, "secret": userSecret, "queueType": "idle", "time": datetime.datetime.utcnow(), "room": "lonely"}
    mdb.userDetails.insert_one(userObj)
    return success(userObj)

# When a selection is made, the user's respective fiels are updated in the db
@app.route('/queue', methods = ['POST'])
@expect_json(secret=str)
def requestQueue(body):
    userObject = mdb.userDetails.find_one({"secret": body['secret']}) # Fetches user from db
    if (userObject != None): # TODO: return different response if user is already in queue or in a room
        mdb.userDetails.update_one({"secret": body['secret']},
                                   {"$set": {"queueType": "inQueue", "time": datetime.datetime.utcnow()}})
        return success("yay, you are in queue now", 200)
    return error(403, "go do auth first you dummy")

# sends message to all users connected to same room as sender
@app.route('/messages', methods = ['POST'])
@expect_json(secret=str, message=str, nonce=str)
def handleMessage(jsonObj):
    userObj = mdb.userDetails.find_one({"secret": jsonObj['secret']})
    if(userObj == None):
        return error(403, "do auth first you dummy")
    room_id = userObj['room']
    user_id = userObj['userID']
    print('Message: ' + jsonObj['message'])
    message = {
        # _id autogenerated
        "room_id": room_id,
        "author": user_id,
        "timestamp": datetime.datetime.now(),
        "nonce": jsonObj['nonce'],
        "content": jsonObj['message']
    }
    mdb.messages.insert_one(message)
    socketio.emit('send_message_to_client', message ,room = room_id)
    return success(message, 201)

# ====== SOCKET STUFF =====
# socket event to have user actually join the room
@socketio.on('join_room')
def user_join_room(secret):
    userObj = mdb.userDetails.find_one({'secret': secret}) # fetch user from db
    if userObj is None:
        print("bad user not found")
        return
    join_room(userObj['room'])
    socketio.emit('user_connected', room=userObj['room'])
    print (userObj['userID'] + ' has joined room ' + userObj['room'])

# user has left your channel
@socketio.on('leave_room')
def user_leave_room(secret):
    userObj = mdb.userDetails.find_one({'secret': secret})  # fetch user from db
    if userObj is None:
        print("bad user not found")
        return
    # todo whatever teardown you need
    socketio.emit('user_disconnected', room=userObj['room'])
    print(userObj['userID'] + ' has left room ' + userObj['room'])

@socketio.on('disconnect')
def user_disconnect():
    # todo
    pass

# ===== MISC =====
def notify_queue_complete():
    socketio.emit("queue_complete", {'user_id': 'blah'})


# register handlers and stuff
errors.register_error_handlers(app)

# ===== DEV ONLY ====
>>>>>>> Stashed changes
# currently, doesn't pop users off the queue, so they stay there
@app.route('/isQueueReady', methods=['GET'])
def isQueueReady():
    # count the number of people in the current queryType
    # eventually replace 1 with whichever queryType user needs
    count = mdb.userDetails.count_documents({"queueType": "idle"})
    if(count >= 2):
        # this should find the first two people in the queue
        query = mdb.userDetails.find(
                {"queueType": "idle"}, {"ip": 1, "secret": 1, "_id": 0}).limit(2)
        output = {}
        i = 0
        for x in query:
            output[i] = x
<<<<<<< Updated upstream
            ip.append(x['ip'])
           # print(ip[i])
            i += 1

=======
            i += 1
>>>>>>> Stashed changes
        print(output)
        return output

    # if there isn't enough people in the 'preferred' queue, then match with someone in another (NOT IMPLEMENTED)
    # if not enough in either, then continue waiting
    else:
<<<<<<< Updated upstream
        print("no one")
=======
        print("no one here")
>>>>>>> Stashed changes
        return "Not enough people..."

# create schedule for printing time
scheduler = BackgroundScheduler()
scheduler.start()
scheduler.add_job(
    func=isQueueReady,
    trigger=IntervalTrigger(seconds=2),
    id='printing_all',
    name='Print all every 2 seconds',
    replace_existing=True)
# Shut down the scheduler when exiting the app
atexit.register(lambda: scheduler.shutdown())


# APScheduler running in background 
scheduler = BackgroundScheduler()
scheduler.start()
scheduler.add_job(
    func=isQueueReady,
    trigger=IntervalTrigger(seconds=2),
    id='check_is_queue_ready',
    name='Check queue statsu every 2 seconds',
    replace_existing=True)
# Shut down the scheduler when exiting the app
atexit.register(lambda: scheduler.shutdown())

if __name__ == '__main__':
    #SocketIO takes the Flask app and wraps the SocketIO functionality around it
    #Typically a Flask app is used in a typical request-response model -  
    #the server will wait for a request to come in, process it, then send a response back
    #
    #SocketIO is more real-time, so the extra functionality is built around this standard Flask app functionality
    #In other words, SocketIO is a specialized add-on to the Flask app functionality for real-time functionality
    socketio.run(app, port=8000)

