import sys

from flask import Flask, render_template, redirect, url_for, jsonify, request, Response
from flask_cors import CORS
from flask_socketio import SocketIO, send, join_room, leave_room
from flask_pymongo import PyMongo
#import config
from pymongo import MongoClient

import db, json, datetime, random, uuid, time
from bson import json_util, ObjectId
from lib import errors
import bot.replier

# Configure app
from lib.utils import clean_json, error, expect_json, success

from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.interval import IntervalTrigger
import atexit
import os

app = Flask(__name__)
app.config['SECRET_KEY'] = 'ttm'
CORS(app)
mdb = MongoClient(db.MONGO_URL).db
socketio = SocketIO(app, cors_allowed_origins='*')
scheduler = BackgroundScheduler()

def is_banned(user_ip):
    if(mdb.bannedUsers.find_one({'ip': user_ip}) is None):
        return False
    else:
        return True

# ===== REST =====
# assign users a generated userID and secret. Stores user in db then redirects to queue selection
@app.route('/auth', methods = ['GET'])
def userAuth():
    userID = str(uuid.uuid4())
    userSecret = str(uuid.uuid4())
    userObj = {
        "ip": request.remote_addr, 
        "userID": userID, 
        "secret": userSecret, 
        "queueType": "idle", 
        "time": time.time(), 
        "room": "lonely", 
        "sid": None}
   
    if(is_banned(userObj['ip'])):
        userObj['queueType'] = "banned"

    mdb.userDetails.insert_one(userObj)
    return success(userObj)

# When a selection is made, the user's respective fiels are updated in the db
@app.route('/queue', methods = ['POST'])
@expect_json(secret=str, queueType=str)
def requestQueue(body): # body will now also contain a queueType field
    userObject = mdb.userDetails.find_one({"secret": body['secret']}) # Fetches user from db
    if (userObject != None):
        if(userObject['queueType'] == "banned"):
            return success("sike, you banned")
        elif(userObject['queueType'] != "idle" or userObject['room'] != "lonely"):
            return error(403, "nah you already in queue or in a room")

        mdb.userDetails.update_one({"secret": body['secret']},
                                   {"$set": {"queueType": body['queueType'], "time": time.time()}})
        return success("you have been placed in queue")
    return error(403, "go do auth first you dummy")

# sends message to all users connected to same room as sender
@app.route('/messages', methods = ['POST'])
@expect_json(secret=str, message=str, nonce=str)
def handleMessage(jsonObj):
    userObj = mdb.userDetails.find_one({"secret": jsonObj['secret']})
    if(userObj == None):
        return error(403, "do auth first you dummy")
    room_id = userObj['room']
    user_id = userObj['userID']
    print('Message: ' + jsonObj['message'])
    message = {
        # _id autogenerated
        "room_id": room_id,
        "author": user_id,
        "timestamp": time.time(),
        "nonce": jsonObj['nonce'],
        "content": jsonObj['message'],
        "liked": False
    }

    # if the user is banned, hand their message off to a bot
    # noinspection PyUnreachableCode
    if False:  # todo: if user_is_banned()
        bot.replier.schedule_reply_to_message(mdb, socketio, scheduler, content=jsonObj['message'], room_id=room_id, user=userObj)
        return success(message, 201)

    # otherwise handle the message as normal
    mdb.messages.insert_one(message)
    socketio.emit('send_message_to_client', clean_json(message) ,room = room_id)
    return success(message, 201)

@app.route('/likes', methods = ['POST'])
@expect_json(secret=str, message_id=str)
def handle_message_like(body):
    user = mdb.userDetails.find_one({"secret": body['secret']})
    if user is None:
        return error(403, "do auth first you dummy")
    room_id = user['room']
    message_id = body["message_id"]
    print(f'Liking message {message_id}')
    mdb.messages.update_one({"_id": ObjectId(message_id)}, {"$set": {"liked": True}})
    socketio.emit('message_liked', {"message_id": message_id, "user_id": user['userID']}, room=room_id)
    return success("message liked", 200)

@app.route('/reports', methods = ['POST'])
@expect_json(secret=str, reason=str)
def handle_report(body):
    user = mdb.userDetails.find_one({"secret": body['secret']})
    if user is None:
        return error(403, "user who clicked on report not found")
    roomObj = mdb.rooms.find_one({"room": user['room']})

    if(roomObj['user1'] == user['userID']):
        reportedUserId = roomObj['user2']
        reportedUserIp = mdb.userDetails.find_one({"userID": reportedUserId}, {"ip": 1, "_id": 0})
        reporterUserIp = mdb.userDetails.find_one({"userID": roomObj['user1']}, {"ip": 1, "_id": 0})

    else:
        reportedUserId = roomObj['user1']
        reportedUserIp = mdb.userDetails.find_one({"userID": reportedUserId}, {"ip": 1, "_id": 0})
        reporterUserIp = mdb.userDetails.find_one({"userID": roomObj['user2']}, {"ip": 1, "_id": 0})

    # insert a Report object into a reports collection
    mdb.reports.insert_one({
        "reporter": user['userID'],
        "reporter_ip": reporterUserIp['ip'],
        "reported": reportedUserId,
        "reported_ip": reportedUserIp['ip'],
        "reason": body['reason'],
        "room_id": roomObj['room']
    })

    # copy all message objs in reported conversation to the other collection
    reportedConversation = mdb.messages.find({"room_id": roomObj['room']})
    mdb.reported_messages.insert_many(list(reportedConversation))
    return success("conversation reported", 200)

# delete userObj from all collections
def delete_user_from_db(userObj):
    mdb.userDetails.delete_one({'secret': userObj['secret']})
    mdb.messages.delete_many({'author': userObj['userID']})
    mdb.rooms.delete_one({'room': userObj['room']})

# makes sure both users have left the room before removing from db
# should only go in here if user closes tab or presses home if in room
def check_users_in_room(room_id):
    roomObj = mdb.rooms.find_one({'room': room_id})
    if roomObj is None:
        print("bad room, not found")
        return

    # at least 1 user disconnected, so this is the 2nd user
    if(roomObj['disconnected'] >= 1):
        user1 = mdb.userDetails.find_one({'userID': roomObj['user1']})
        user2 = mdb.userDetails.find_one({'userID': roomObj['user2']})
        delete_user_from_db(user1)
        delete_user_from_db(user2)
    else:
        mdb.rooms.update_one({'room': room_id}, {"$set": {'disconnected': 1}})

# ====== SOCKET STUFF =====
# socket event to have user actually join the room
@socketio.on('join_room')
def user_join_room(secret):
    userObj = mdb.userDetails.find_one({'secret': secret}) # fetch user from db
    if userObj is None:
        print("bad user not found")
        return
    join_room(userObj['room'])
    socketio.emit('user_connected', room=userObj['room'])
    print (userObj['userID'] + ' has joined room ' + userObj['room'])

# associates a SocketIO session ID with a user object. This is called immediately after the user auths
@socketio.on('hello')
def user_sid_assoc(secret):
    user = mdb.userDetails.find_one({'secret': secret})  # fetch user from db
    if user is None:
        print("user_sid_assoc: user not found")
        return
    # noinspection PyUnresolvedReferences
    # provided by socketio
    sid = request.sid
    mdb.userDetails.update_one({'secret': secret}, {"$set": {"sid": sid}})
    print("User {user['userID']} has socket session ID" + sid)

# user has left your channel
@socketio.on('leave_room')
def user_leave_room(secret):
    userObj = mdb.userDetails.find_one({'secret': secret})  # fetch user from db
    if userObj is None:
        print("bad user not found")
        return
    # todo whatever teardown you need
    leave_room(userObj['room'])
    socketio.emit('user_disconnected', room=userObj['room'])
    # delete these 2 users from messages, rooms, and queue
    # delete_user_from_db(userObj) let's see if we can not remove users when they leave room, we need this info
    check_users_in_room(userObj['room'])
    print(userObj['userID'] + ' has left room ' + userObj['room'])

@socketio.on('disconnect')
def user_disconnect(): # ensure that eventlet is installed!!
    userObj = mdb.userDetails.find_one({'sid': request.sid})  # fetch user from db
    if(userObj is None): # still not sure why this would happen but here's protection in case
        return
    socketio.emit('user_disconnected', room=userObj['room'])

    # check to see if user disconnected while in room or in a queue
    if(userObj['queueType'] == "outQueue"):
        check_users_in_room(userObj['room'])
    else:
        delete_user_from_db(userObj)
    print("yay user has been deleted")
   
# ===== MISC =====
# register handlers and stuff
errors.register_error_handlers(app)

# ===== DEV ONLY ====

def notify_queue_complete(user_id):
    socketio.emit("queue_complete", {'user_id' : user_id[0]})
    socketio.emit("queue_complete", {'user_id' : user_id[1]})

def match_making(userIDs):
    roomID = str(uuid.uuid4())
    user_ID1 = userIDs[0]
    user_ID2 = userIDs[1]
    mdb.rooms.insert_one({"room" : roomID, 'user1' : user_ID1, 'user2' : user_ID2, "disconnected": 0})
    mdb.userDetails.update_one({"userID" : user_ID1}, {"$set": {'room': roomID, "queueType": "outQueue"}})
    mdb.userDetails.update_one({"userID" : user_ID2}, {"$set": {'room': roomID, "queueType": "outQueue"}})
    print("user " + user_ID1 + " and user " + user_ID2 + " have been assigned room " + roomID)

# enough time passes to go to fall back queue(talk)
def find_time_difference(userTime):
    difference = (time.time() - userTime)
    return (int(difference) > 10)

def change_vent_listen_to_talk(query):
    for x in query:
        if(find_time_difference(x['time'])):
            mdb.userDetails.update_one({"secret": x['secret']}, {
                "$set": {"queueType": "talk"}})

# matchs vent with listen (vice versa), matches talk with talk
# keeps in one collection instead of multiple for each queueType
# problematic if large number of people
def check_queue():
    countVent = mdb.userDetails.count_documents({"queueType": "vent"})
    countListen = mdb.userDetails.count_documents({"queueType": "listen"})
    
    # --------MATCH MAKING FOR VENT OR LISTEN----------

    # at least 1 person in either vent or listen
    if (countVent + countListen) > 0:
        # at least 1 person in vent AND listen, so match them
        if(countVent >= 1 & countListen >= 1):
            getVent = mdb.userDetails.find_one({"queueType": "vent"})
            getListen = mdb.userDetails.find_one({"queueType": "listen"})
            
            # if someone leaves the queue at this moment
            # there might be a better way to write this case
            if(getVent is None or getListen is None):
                return

            userIDs = []
            userIDs.append(getVent['userID'])
            userIDs.append(getListen['userID'])

            match_making(userIDs)
            notify_queue_complete(userIDs)
        # means 1 person or more in either vent/listen and no one in the other
        # checks if they been waiting too long and changes them to talk
        else:
            if(countListen == 0): # no one in listen
                queryVent = mdb.userDetails.find({"queueType": "vent"}, {"time": 1, "secret": 1, "_id": 0})
                change_vent_listen_to_talk(queryVent)
            else: # no one in vent
                queryListen = mdb.userDetails.find({"queueType": "listen"}, {"time": 1, "secret": 1, "_id": 0})
                change_vent_listen_to_talk(queryListen)
            
    # ------------MATCH MAKING FOR TALK--------------
    # matchmaking for talk (same as isQueueReady)
    countTalk = mdb.userDetails.count_documents({"queueType": "talk"})
    if(countTalk >= 2):
        # this should find the first two people in the queue
        query = mdb.userDetails.find(
                {"queueType": "talk"}, {"userID": 1, "secret": 1, "_id": 0}).limit(2)
        userIDs = []
        for x in query:
            userIDs.append(x['userID'])
        match_making(userIDs)
        notify_queue_complete(userIDs) # pass user_id into notify_queue_complete()

# ---------------------MAKE SURE TO REMOVE THESE ON RELEASE-----------------------------
# deletes all documents in UserDetails
@app.route('/deleteUserDetails')
def delete_user_details():
    mdb.userDetails.delete_many({})
    return "deleted all docs in userDetails"

@app.route('/deleteRoomDetails')
def delete_room_details():
    mdb.rooms.delete_many({})
    return "deleted all docs in rooms"

@app.route('/deleteMessageDetails')
def delete_message_details():
    mdb.messages.delete_many({})
    return "deleted all docs in messages"


@app.route('/deleteAllDetails')
def delete_all_details():
    mdb.userDetails.delete_many({})
    mdb.rooms.delete_many({})
    mdb.messages.delete_many({})
    mdb.reported_messages.delete_many({})
    mdb.reports.delete_many({})
    mdb.bannedUsers.delete_many({})
    return "all gone!"

# APScheduler running in background 
scheduler.add_job(
    func=check_queue,
    trigger="interval", 
    seconds=3,
    id='check_is_queue_ready',
    name='Check queue status every 3 seconds',
    replace_existing=True)
scheduler.start()
# Shut down the scheduler when exiting the app
atexit.register(lambda: scheduler.shutdown())

if __name__ == '__main__':
    socketio.run(app, port=8000, host="0.0.0.0")
